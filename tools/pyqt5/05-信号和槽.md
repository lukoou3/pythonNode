## 事件与信号处理
GUI应用程序是事件驱动的。 事件主要由应用程序的用户生成。 但它们也可以通过其他手段产生，例如：网络连接，窗口管理器或定时器。 当我们调用应用程序的exec_（）方法时，应用程序进入主循环。 主循环获取事件并将其发送到对象。

在事件模型中，有三个参与者：  
* 事件来源  
* 事件对象  
* 事件目标  

事件源是其状态更改的对象。 它会生成事件。 事件对象（event）将状态更改封装在事件源中。 事件目标是要通知的对象。 事件源对象将处理事件的任务委托给事件目标。  

PyQt5具有独特的信号和插槽机制来处理事件。 信号和槽用于对象之间的通信。 发生特定事件时发出信号。 槽可以是任何Python可调用的函数。 当发射连接的信号时会调用一个槽。

### 信号和槽
信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。它为高层次的事件处理自动生成所需要的附加代码。在我们所熟知的很多 GUI 工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。

所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。

你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。



说实话对于像我这样的新手来说看着就蛋疼，想学会它没办法，我们还是简化一下概念吧：  
```
所有QObject类都可以使用信号槽，换句话来说继承自pyqt中的类基本上都可以使用信号槽机制。当然非QObject也是可以通过其他一些办法来使用信号槽的。
仅仅有了信号和槽是不行的，我们还需要了解：  
信号(Signal)、槽(slot)、连接(connect)、动作事件(action)、发射(emit)、发送者、接受者等等一些列的知识。
```

### 简单的信号与槽示例
代码：
```python
import sys
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QWidget, QLCDNumber, QDial, QApplication)

class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUi()

    def initUi(self):
        lcd = QLCDNumber(self)
        dial = QDial(self)

        self.setGeometry(300, 300, 350, 250)
        self.setWindowTitle('学点编程吧')

        lcd.setGeometry(100,50,150,60)
        dial.setGeometry(120,120,100,100)

        dial.valueChanged.connect(lcd.display)

        self.show()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
```
这个例子的执行结果如下：
![程序执行](/assets/程序执行.gif)

绑定槽函数的代码：
```python
dial.valueChanged.connect(lcd.display)
```

### 继承重载pyqt对象的事件函数来处理信号
重写QWidget的keyPressEvent函数来控制按下按钮后要如何处理
```python
import sys
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QWidget, QApplication, QLabel)
class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUi()
    def initUi(self):
        self.setGeometry(300, 300, 350, 250)
        self.setWindowTitle('学点编程吧')
        self.lab = QLabel('方向',self)
        self.lab.setGeometry(150,100,50,50)
        self.show()
    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Up:
            self.lab.setText('↑')
        elif e.key() == Qt.Key_Down:
            self.lab.setText('↓')
        elif e.key() == Qt.Key_Left:
            self.lab.setText('←')
        else:
            self.lab.setText('→')
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
```
这个例子的执行结果如下：
![方向](/assets/方向.gif)

### 获取信号的发送者
有时，知道哪个窗口小部件是信号的发送者非常有用。 为此，PyQt5具有sender()方法。例如下面这个例子，我们实现了简单的石头、剪刀、布的小游戏。
```python
import sys
from PyQt5.QtWidgets import (QApplication, QMessageBox, QWidget, QPushButton)
from random import randint
class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
    def initUI(self):
        self.setGeometry(200, 200, 300, 300)
        self.setWindowTitle('学点编程吧')
        bt1 = QPushButton('剪刀',self)
        bt1.setGeometry(30,180,50,50)
        bt2 = QPushButton('石头',self)
        bt2.setGeometry(100,180,50,50)
        bt3 = QPushButton('布',self)
        bt3.setGeometry(170,180,50,50)
        bt1.clicked.connect(self.buttonclicked)
        bt2.clicked.connect(self.buttonclicked)
        bt3.clicked.connect(self.buttonclicked)
        self.show()
    def buttonclicked(self):
        computer = randint(1,3)
        player = 0
        sender = self.sender()
        if sender.text() == '剪刀':
            player = 1
        elif sender.text() == '石头':
            player = 2
        else:
            player = 3
        if player == computer:
            QMessageBox.about(self, '结果', '平手')
        elif player == 1 and computer == 2:
            QMessageBox.about(self, '结果', '电脑：石头，电脑赢了！')
        elif player == 2 and computer == 3:
            QMessageBox.about(self, '结果', '电脑：布，电脑赢了！')
        elif player == 3 and computer == 1:
            QMessageBox.about(self,'结果','电脑：剪刀，电脑赢了！')
        elif computer == 1 and player == 2:
            QMessageBox.about(self,'结果','电脑：剪刀，玩家赢了！')
        elif computer == 2 and player == 3:
            QMessageBox.about(self,'结果','电脑：石头，玩家赢了！')
        elif computer == 3 and player == 1:
            QMessageBox.about(self,'结果','电脑：布，玩家赢了！')
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
```
这个例子的执行结果如下：
![石头剪刀布](/assets/石头剪刀布.gif)

### 自定义信号
#### 用pyqtSignal定义新信号
PyQt5自动定义所有Qt内置信号的信号。可以使用pyqtSignal工厂将新信号定义为类属性。新信号只应在QObject的子类中定义 。它们必须是类定义的一部分，并且在定义类之后不能作为类属性动态添加。
```python 
PyQt5.QtCore.pyqtSignal（types [，name [，revision = 0 [，arguments = [] ] ] ] ）
```
创建一个或多个重载的未绑定信号作为类属性。  
参数：	
* types - 定义信号的C ++签名的类型。每种类型可以是Python类型对象，也可以是C ++类型名称的字符串。或者，每个可以是一系列类型参数。在这种情况下，每个序列定义不同信号过载的签名。第一个重载将是默认值。  
* name - 信号的名称。如果省略，则使用class属性的名称。这可能只作为关键字参数给出。  
* revision - 导出到QML的信号的修订版。这可能只作为关键字参数给出。  
* arguments - 导出到QML的信号参数名称的序列。这可能只作为关键字参数给出。  

返回类型：  	 
* 一个未绑定的信号  


以下示例显示了许多新信号的定义：
```python 
from PyQt5.QtCore import QObject, pyqtSignal

class Foo(QObject):

    # This defines a signal called 'closed' that takes no arguments.
    closed = pyqtSignal()

    # This defines a signal called 'rangeChanged' that takes two
    # integer arguments.
    range_changed = pyqtSignal(int, int, name='rangeChanged')

    # This defines a signal called 'valueChanged' that has two overloads,
    # one that takes an integer argument and one that takes a QString
    # argument.  Note that because we use a string to specify the type of
    # the QString argument then this code will run under Python v2 and v3.
    valueChanged = pyqtSignal([int], ['QString'])
```

以下代码演示了不带参数的信号的定义，连接和发出：
```python 
from PyQt5.QtCore import QObject, pyqtSignal

class Foo(QObject):

    # Define a new signal called 'trigger' that has no arguments.
    trigger = pyqtSignal()

    def connect_and_emit_trigger(self):
        # Connect the trigger signal to a slot.
        self.trigger.connect(self.handle_trigger)

        # Emit the signal.
        self.trigger.emit()

    def handle_trigger(self):
        # Show that the slot has been called.

        print "trigger signal received"
```

自定义信号例子：
```python 
from PyQt5 import QtWidgets,QtCore
from untitled import Ui_Form
import  time
  
class MyWindow(QtWidgets.QWidget,Ui_Form):
    _signal=QtCore.pyqtSignal(str)                         #定义信号,定义参数为str类型
    def __init__(self):  
        super(MyWindow,self).__init__()
        self.setupUi(self)
        self.myButton.clicked.connect(self.myPrint)
        self._signal.connect(self.mySignal)               #将信号连接到函数mySignal
 
    def myPrint(self):
        self.tb.setText("")
        self.tb.append("正在打印，请稍候")
        self._signal.emit("你妹，打印结束了吗，快回答！")
    def mySignal(self,string):
        print(string)
        self.tb.append("打印结束")
 
if __name__=="__main__":  
    import sys  
  
    app=QtWidgets.QApplication(sys.argv)  
    myshow=MyWindow()
    myshow.show()  
    sys.exit(app.exec_())  

```
